---
title: "CSAMA2019: Mass spectrometry and proteomics lab"
author:
- name: Laurent Gatto
  affiliation: Computational Biology group, de Duve Institute, UCLouvain, Belgium
- name: Lieven Clemen
  affiliation: statOmics group, Gent University, Belgium
output:
  BiocStyle::html_document
---

# TODO

- smallestUniqueGroup
- proteinGroupsFile with peptides with PTMs
- compare median vs robust

# Introduction

This tutorial requires  the
`r BiocStyle::Biocpkg("MSnbase")`, 
`r BiocStyle::Githubpkg("statOmics/MSqRob")` 
`r BiocStyle::Biocpkg("limma")` and
`r BiocStyle::Biocexptpkg("msdata")` packages, as well as some of the
`r BiocStyle::CRANpkg("tidyverese")` packages 
for data tidying and visualisation.

```{r env, message = FALSE}
library("MSnbase")
library("MSqRob")
library("msdata")
library("limma")
```

A longer version of the material is available
[here](https://rawgit.com/lgatto/bioc-ms-prot/master/lab.html).


# Data files in mass spectrometry

Most community-driven formats described in the table are supported in
`R`. We will see how to read and access these data in the following
sections.

```{r datatab, results='asis', echo=FALSE}
datatab <-
    data.frame(Type = c("raw", "identification", "quantitation",
                   "peak lists", "quant and id", "protein db"),
               Format = c("mzML, mzXML, netCDF, mzData",
                   "mzIdentML", "mzQuantML", "mgf", "mzTab", "fasta"),
               Package = c(
                   "*[MSnbase](http://bioconductor.org/packages/MSnbase)* (read and write in version >= 2.3.13) via *[mzR](http://bioconductor.org/packages/mzR)*",
                   paste("*[mzID](http://bioconductor.org/packages/mzID)* (read) and",
                         "*[MSnbase](http://bioconductor.org/packages/MSnbase)* (read, via *[mzR](http://bioconductor.org/packages/mzR)*)"),
                   "",
                   "*[MSnbase](http://bioconductor.org/packages/MSnbase)* (read)",
                   "*[MSnbase](http://bioconductor.org/packages/MSnbase)* (read)",
                   "*[Biostrings](http://bioconductor.org/packages/Biostrings)*"))

knitr::kable(datatab)
```

# Loading raw data

Raw data files (in any of the above formats) is read into R using
`MSnbase::readMSData` function that will return an list-like object of
class `MSnExp`.

```{r data1}
basename(fl3 <- msdata::proteomics(full.name = TRUE, pattern = "MS3TMT11"))
(rw3 <- readMSData(fl3, mode = "onDisk"))
```

Note: above, we specify to use the *on disk* mode (as opposed to *in
memory*) to avoid loading the whole raw data file(s) into memory. With
*on disk*, the raw data will be accessed on demand. Here, we only read
a single MS file into R, but with *on disk* mode, we could load 100s
thereof.

An `MSnExp` object contains 

- the raw data (spectra), accessible with `[` and `[[`
- features data, accessible as a dataframe with `fData`

We can also access specific data using

- `msLevel(rw3)`
- `rtime(rw3)`
- `precursorMz(rw3)`
- `centroided(rw3)`
- ...

See `?MSnExp` for details.


**Exercise**: Using `msLevel`, extract the MS level of the
`length(rw3)` spectra of the `rw3` file. What levels are available in
these data. Using `centroided`, check what spectra and centroided of
in profile mode. Which are the levels that are centroided or in
profile mode.

<details>

```{r ex1}
table(msLevel(rw3), centroided(rw3))
```
</details>

# Loading identification data

Idenfification data in `mzId` is parsed and loaded as a `data.frame`
using the `readMzIdData` function.


```{r id}
basename(idf <- msdata::ident(full.name = TRUE))
iddf <- readMzIdData(idf)
```

Among the identification variables available, you will find
`MS.GF.RawScore`, the identification score computated by MSGF+ (the
search engine used for the search), and `isDecoy`. 

```{idvars}
names(iddf)
```

**Exercise**: Reproduce and interpret the plot showing the
identification score distribution for the decoy and real peptides in
this file.


<details>

```{r fdrplot}
library("ggplot2")
ggplot(iddf, aes(x = MS.GF.RawScore, colour = isDecoy)) +
    geom_density()
```
</details>


# Combining raw and identification data

When working with raw and identification data, these two can be merged
by adding the identification results to the raw feature meta-data
slot. Below, we use small data that is shipped with the `MSnbase`
package. The raw data being very small, we can afford to read it into
memory without specifying `mode = "onDisk"`.


```{r addid}
basename(quantFile <- dir(system.file(package = "MSnbase", dir = "extdata"),
                 full.name = TRUE, pattern = "mzXML$"))
basename(identFile <- dir(system.file(package = "MSnbase", dir = "extdata"),
                          full.name = TRUE, pattern = "dummyiTRAQ.mzid"))
     
msexp <- readMSData(quantFile)
fvarLabels(msexp)
```

Add this stage, there's only one `spectrum` feature variable with the
spectra indices. Below we add the identification data with
`addIdentificationData` to gain 33 new feature variables.


```{r addid2}
msexp <- addIdentificationData(msexp, identFile)
fvarLabels(msexp)
```

Note that prior to addition, the identification data is filtered as
documented in the `filterIdentificationDataFrame` function:

1. only PSMs matching the regular (non-decoy) database are retained;
2. PSMs of rank greater than 1 are discarded; 
3. only proteotypic peptides are kept.


# Quantitative data

Quantiative data is stored a objects of class `MSnSet`, which can be 

```{r msnset, fig.cap = "The MSnSet structure", echo = FALSE}
knitr::include_graphics("./Figures/msnset.png")
```

1. Created from an `MSnExp` object with the `quantify` function.

```{r quant}
data(itraqdata)
itraqdata
msnset <- quantify(itraqdata, method = "trap", reporters = iTRAQ4)
msnset
```

```{r qvis, fig.cap = "Raw data and quantiative results"}
plot(itraqdata[[1]], reporters = iTRAQ4, full = TRUE)
exprs(msnset)[1, ]
fData(msnset)[1, ]
```

2. Created from a spreadsheet produced by a third party software using
   the `readMSnSet2` function.

We are going to use the `cptac_a_b_peptides.txt` file from the
`msdata` package. These data are the 6th study of the Clinical
Proteomic Technology Assessment for Cancer (CPTAC). In this
experiment, the authors spiked the Sigma Universal Protein Standard
mixture 1 (UPS1) containing 48 different human proteins in a protein
background of 60 ng/μL Saccharomyces cerevisiae strain BY4741 (MATa,
leu2Δ0, met15Δ0, ura3Δ0, his3Δ1). Two different spike-in
concentrations were used: 6A (0.25 fmol UPS1 proteins/μL) and 6B (0.74
fmol UPS1 proteins/μL). We limited ourselves to the data of
LTQ-Orbitrap W at site 56. The data were searched with MaxQuant
version 1.5.2.8, and detailed search settings were described in
Goeminne *et al.* (2016). Three replicates are available for each
concentration.

The study is a spike-in study for which we know the ground truth so we
have the ability to evaluate the quality of the fold change estimates
and the list of DE genes that we return with a method.


```{r cptacfile}
basename(f <- msdata::quant(full.names = TRUE))
```

Before reading the spreadsheet, we need to identify which columns
contain quantitation data (that will be put into the `exprs` slot)
and the feature data (that will be put into the `fData` slot).

Below `getEcols` lists the column names in the expression data
spreadsheet. The quantitative values we want to used are those in the
columns starting with `Intensity 6A_7`, `Intensity 6A_8`, ... 
`Intensity 6B_9`, that we refer to with `Intensity `. 


```{r read0}
getEcols(f, split = "\t")
```

Using the pattern, we can set the coulumns to be used to populate the
quantitation slot.


```{r read}
(e <- grepEcols(f, "Intensity ", split = "\t")) ## careful at the space!
(cptac <- readMSnSet2(f, ecol = e,
                      fnames = "Sequence",
                      sep = "\t"))
```


We can access the expression data with `exprs` and the feature
meta-data with `fData`.

```{r exprs_and_fData}
head(exprs(cptac))
tail(exprs(cptac))
fvarLabels(cptac)
```

For the sake of simplicity, we can clean up the feature variables and
only keep those of interest. It is possible to do this interactively
with

```{r selectfeats0, eval = FALSE}
cptac <- selectFeatureData(cptac)
```

or by setting the feature variables of interest.

```{r selectfeats}
cptac <- selectFeatureData(cptac,
                           fcol = c("Proteins",
                                    "Potential.contaminant",
                                    "Reverse",
                                    "Sequence"))
```

Let's also add sample annotations:

```{r pdata}
cptac$condition <- rep(c("A", "B"), each = 3)
cptac$sample <- rep(7:9, 2)
sampleNames(cptac) <- sub("Intensity.", "", sampleNames(cptac))
pData(cptac)
```

This could also be done by reading a spreadsheet into R as a
`data.frame`, making sure that the rownames match the sample names
exactly, and then adding it with `pData(cptac) <- myDf`.


The sample names are rather long and contain information on the
spike-in concentration and the repeat. We this remove `Intensity.6`
from the sample names:

```{r snms}
sampleNames(cptac) <- sub("Intensity\\.6", "", sampleNames(cptac))
sampleNames(cptac) 
```

# Quantitative data processing

## Filtering out contaminants 

Below, we create vector of logicals (and count) recording peptides
that are assigned to contaminant and recerse proteins. These are
annotated with a `"+"` in the respective `"Potential.contaminant"` and
`"Reverse"` feature variables.


```{r conts}
table(sel_conts <- fData(cptac)$Potential.contaminant != "+")
```

```{r rev}
table(sel_rev <- fData(cptac)$Reverse != "+")
```

```{r filtering}
(cptac <- cptac[sel_conts & sel_rev, ])
```

Note how the filtering has been recorded in the object's processing
log.


## Notes on missing values

Unfortunately, some software uses 0 irrespecitve whether the data has
intensity zero and when the data haven't been observer. Below we fix
this by setting all 0 values to `NA`.


```{r setna}
exprs(cptac)[exprs(cptac) == 0] <- NA
table(is.na(exprs(cptac)))
```

```{r napac, fig.cap = "Overview of missing data"}
napac <- cptac
exprs(napac)[!is.na(exprs(napac))] <- 1
naplot(napac)
```

```{r nna}
fData(cptac)$nNA <- apply(exprs(cptac), 1, function(x) sum(is.na(x)))
table(fData(cptac)$nNA)
```

(Note that some peptides aren't seen at all because these 6 samples
are a subset of a larger dataset, and these features are present in
the other acquisitions.)

From here on, one could **filter** data with missing values, which
however sacrifices a lot of data.

```{r filterNA}
filterNA(cptac)
```

Perform **imputation**, considering the underlying nature of missingness,
i.e missing not at random (left-censored) or at random.

![Root-mean-square error (RMSE) observations standard deviation ratio (RSR), KNN and MinDet imputation. Lower (blue) is better.](./Figures/imp-sim.png)

See Lazar *et al.* [Accounting for the Multiple Natures of Missing
Values in Label-Free Quantitative Proteomics Data Sets to Compare
Imputation
Strategies](http://dx.doi.org/10.1021/acs.jproteome.5b00981).

The best solution is arguably to handle missing values at **the
statistical test level**, which is the approach we are going to use.

We are going to keep peptides that had a least two observations. This
can be done with the `nNA` variable that we compute above

```{r nNAfilt}
cptac <- cptac[fData(cptac)$nNA <= 4, ]
```

## Log transformation

```{r log}
(cptac <- log(cptac, base = 2))
```

## Normalisation

Normalisation is handled by the `normalise` (or `normalize`) function.

```{r norm}
plotDensities(exprs(cptac))
(cptac <- normalise(cptac, method = "quantiles"))
plotDensities(exprs(cptac))
```

We can visualize our data using a Multi Dimensional Scaling (MDS)
plot, using the `plotMDS` function from the `limma` package. We use
the condition sample variable to colour-code the samples.


```{r mds0}
plotMDS(exprs(cptac), col = as.numeric(as.factor(cptac$condition)))
```

The first axis in the plot is showing the leading log fold changes
(differences on the log scale) between the samples.  We notice that
the leading differences (log FC) in the peptide data seems to be
driven by technical variability.  Indeed the samples do not seem to be
clearly separated according to the spike in condition.  


## Summarisation

So far we have quantitation values at the peptide level, while the
level of interest are proteins. We can take all peptides that are
associated to a protein (or protein group), as defined by the
`Proteins` feature variable and aggregate them using a preferred
operation.

```{r featsfig, fig.cap = "Aggregation between different levels.", echo = FALSE}
knitr::include_graphics("https://rformassspectrometry.github.io/Features/articles/Features_files/figure-html/featuresplot-1.png")
```


```{r featsfig2, fig.cap = "Examples of aggregations.", echo = FALSE}
knitr::include_graphics("https://rformassspectrometry.github.io/Features/articles/Features_files/figure-html/plotstat-1.png")
```

```{r combine_med}
(cptac_median <- combineFeatures(cptac, fcol = "Proteins", method = "median", na.rm = TRUE))
```

Because there are missing values for the peptide level data we use the
`na.rm=TRUE` argument to summarize the data based on the observed
peptides for every protein.


```{r mds1}
plotMDS(exprs(cptac_median), col = as.numeric(as.factor(cptac$condition)))
```

**Exercise**: Repeat the summarisation using a more robust
normalisation by setting `method = "robjust"`, as described in [Sticker *et
al*. (2019)](https://www.biorxiv.org/content/10.1101/668863v1) and
visualise the data on an MDS plot. Which one do you anticipate to
provide better results?

<details>
```{r combine_rob}
cptac_rob <- combineFeatures(cptac, fcol = "Proteins", method = "robust", na.rm = TRUE)
plotMDS(exprs(cptac_rob), col = as.numeric(as.factor(cptac$condition)))
```
</details>


# Data Analysis

## Estimation

MSqRob is currently working with a format where we have one dataframe
for each protein.  This will be changed in the next release.
Therefore we first have to reorganise the data.

Next the models are fitted. This is done using the `fit.model`
function.  We only have to model the data using the factor condition
from the pheno data of the protein level MSnSet.  The name of the
factor variable is specified in the fixed argument (if multiple
predictors have to be incorporated in the model, a vector of variable
names has to be provided in this argument). The argument shrinkage is
used to specify if ridge regression has to be adopted.  For the sake
of speed we do not do this in the tutorial. The shrinkage has to be
specified for each variable in the fixed effects. We also have to
indicate this for the intercept (which we never shrink).  So we
specify it at `c(0, 0)` to indicate that the intercept (first 0) and
the parameters for the factor condition (second 0) are not penalized.
We set the `robust_var` function equal to `FALSE`, this functionality
will be removed from the package in the next release.


```{r models, cache = TRUE}
protMSqRob <- MSnSet2protdata(cptac_rob, "Proteins")
models <- fit.model(protdata = protMSqRob,
                    response = "quant_value",
                    fixed = "condition",
                    shrinkage.fixed = c(0, 0),
                    robust_var = FALSE)
```

## Inference

Many biologists have problems with the reference coding.  In MSqRob we
have opted to formulate contrasts using all levels of a factor.
Internally, the contrasts are than recasted according to the factor
level that is the reference class.

```{r}
L <- makeContrast("conditionB - conditionA",
                  levels = c("conditionA", "conditionB"))
tests <- test.contrast_adjust(models, L)
nSig <- sum(tests$signif, na.rm = TRUE)
head(tests)
```

There are`r nSig` proteins with a significant effect at the 5% FDR level. 


# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
