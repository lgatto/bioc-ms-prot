---
title: "CSAMA2019: Mass spectrometry and proteomics lab"
author:
- name: Laurent Gatto
  affiliation: Computational Biology group, de Duve Institute, UCLouvain, Belgium
- name: Lieven Clemen
  affiliation: statOmics group, Gent University, Belgium
output:
  BiocStyle::html_document
---

# Introduction

This tutorial requires `r BiocStyle::Biocpkg("MSnbase")` and 
`r BiocStyle::Biocexptpkg("msdata")` package. 

```{r env, message = FALSE}
library("MSnbase")
library("msdata")
```

A longer version of the material is available
[here](https://rawgit.com/lgatto/bioc-ms-prot/master/lab.html).


# Data files in mass spectrometry

Most community-driven formats described in the table are supported in
`R`. We will see how to read and access these data in the following
sections.

```{r datatab, results='asis', echo=FALSE}
datatab <-
    data.frame(Type = c("raw", "identification", "quantitation",
                   "peak lists", "quant and id", "protein db"),
               Format = c("mzML, mzXML, netCDF, mzData",
                   "mzIdentML", "mzQuantML", "mgf", "mzTab", "fasta"),
               Package = c(
                   "*[MSnbase](http://bioconductor.org/packages/MSnbase)* (read and write in version >= 2.3.13) via *[mzR](http://bioconductor.org/packages/mzR)*",
                   paste("*[mzID](http://bioconductor.org/packages/mzID)* (read) and",
                         "*[MSnbase](http://bioconductor.org/packages/MSnbase)* (read, via *[mzR](http://bioconductor.org/packages/mzR)*)"),
                   "",
                   "*[MSnbase](http://bioconductor.org/packages/MSnbase)* (read)",
                   "*[MSnbase](http://bioconductor.org/packages/MSnbase)* (read)",
                   "*[Biostrings](http://bioconductor.org/packages/Biostrings)*"))

knitr::kable(datatab)
```

# Loading raw data

Raw data files (in any of the above formats) is read into R using
`MSnbase::readMSData` function that will return an list-like object of
class `MSnExp`.

```{r data1}
basename(fl3 <- msdata::proteomics(full.name = TRUE, pattern = "MS3TMT11"))
(rw3 <- readMSData(fl3, mode = "onDisk"))
```

Note: above, we specify to use the *on disk* mode (as opposed to *in
memory*) to avoid loading the whole raw data file(s) into memory. With
*on disk*, the raw data will be accessed on demand. Here, we only read
a single MS file into R, but with *on disk* mode, we could load 100s
thereof.

An `MSnExp` object contains 

- the raw data (spectra), accessible with `[` and `[[`
- features data, accessible as a dataframe with `fData`

We can also access specific data using

- `msLevel(rw3)`
- `rtime(rw3)`
- `precursorMz(rw3)`
- `centroided(rw3)`
- ...

See `?MSnExp` for details.


**Exercise**: Using `msLevel`, extract the MS level of the
`length(rw3)` spectra of the `rw3` file. What levels are available in
these data. Using `centroided`, check what spectra and centroided of
in profile mode. Which are the levels that are centroided or in
profile mode.

<details>

```{r ex1}
table(msLevel(rw3), centroided(rw3))
```
</details>

# Loading identification data

Idenfification data in `mzId` is parsed and loaded as a `data.frame`
using the `readMzIdData` function.


```{r id}
basename(idf <- msdata::ident(full.name = TRUE))
iddf <- readMzIdData(idf)
```

Among the identification variables available, you will find
`MS.GF.RawScore`, the identification score computated by MSGF+ (the
search engine used for the search), and `isDecoy`. 

```{idvars}
names(iddf)
```

**Exercise**: Reproduce and interpret the plot showing the
identification score distribution for the decoy and real peptides in
this file.


<details>

```{r fdrplot}
library("ggplot2")
ggplot(iddf, aes(x = MS.GF.RawScore, colour = isDecoy)) +
    geom_density()
```
</details>


# Combining raw and identification data

When working with raw and identification data, these two can be merged
by adding the identification results to the raw feature meta-data
slot. Below, we use small data that is shipped with the `MSnbase`
package. The raw data being very small, we can afford to read it into
memory without specifying `mode = "onDisk"`.


```{r addid}
basename(quantFile <- dir(system.file(package = "MSnbase", dir = "extdata"),
                 full.name = TRUE, pattern = "mzXML$"))
basename(identFile <- dir(system.file(package = "MSnbase", dir = "extdata"),
                          full.name = TRUE, pattern = "dummyiTRAQ.mzid"))
     
msexp <- readMSData(quantFile)
fvarLabels(msexp)
```

Add this stage, there's only one `spectrum` feature variable with the
spectra indices. Below we add the identification data with
`addIdentificationData` to gain 33 new feature variables.


```{r addid2}
msexp <- addIdentificationData(msexp, identFile)
fvarLabels(msexp)
```

Note that prior to addition, the identification data is filtered as
documented in the `filterIdentificationDataFrame` function:

1. only PSMs matching the regular (non-decoy) database are retained;
2. PSMs of rank greater than 1 are discarded; 
3. only proteotypic peptides are kept.


# Quantitative data

Quantiative data is stored a objects of class `MSnSet`, which can be 

```{r msnset, fig.cap = "The MSnSet structure", echo = FALSE}
knitr::include_graphics("./Figures/msnset.png")
```

1. Created from an `MSnExp` object with the `quantify` function.

```{r quant}
data(itraqdata)
itraqdata
msnset <- quantify(itraqdata, method = "trap", reporters = iTRAQ4)
msnset
```

```{r qvis, fig.cap = "Raw data and quantiative results"}
plot(itraqdata[[1]], reporters = iTRAQ4, full = TRUE)
exprs(msnset)[1, ]
fData(msnset)[1, ]
```

2. Created from a spreadsheet produced by a third party software using
   the `readMSnSet2` function.

We are going to use the `cptac_a_b_peptides.txt` file from the
`msdata` package. These data are the 6th study of the Clinical
Proteomic Technology Assessment for Cancer (CPTAC). In this
experiment, the authors spiked the Sigma Universal Protein Standard
mixture 1 (UPS1) containing 48 different human proteins in a protein
background of 60 ng/μL Saccharomyces cerevisiae strain BY4741 (MATa,
leu2Δ0, met15Δ0, ura3Δ0, his3Δ1). Two different spike-in
concentrations were used: 6A (0.25 fmol UPS1 proteins/μL) and 6B (0.74
fmol UPS1 proteins/μL). We limited ourselves to the data of
LTQ-Orbitrap W at site 56. The data were searched with MaxQuant
version 1.5.2.8, and detailed search settings were described in
Goeminne *et al.* (2016). Three replicates are available for each
concentration.

The study is a spike-in study for which we know the ground truth so we
have the ability to evaluate the quality of the fold change estimates
and the list of DE genes that we return with a method.


```{r cptacfile}
basename(f <- msdata::quant(full.names = TRUE))
```

Before reading the spreadsheet, we need to identify which columns
contain quantitation data (that will be put into the `exprs` slot)
and the feature data (that will be put into the `fData` slot).

Below `getEcols` lists the column names in the expression data
spreadsheet. The quantitative values we want to used are those in the
columns starting with `Intensity 6A_7`, `Intensity 6A_8`, ... 
`Intensity 6B_9`, that we refer to with `Intensity `. 


```{r read0}
getEcols(f, split = "\t")
```

Using the pattern, we can set the coulumns to be used to populate the
quantitation slot.


```{r read}
(e <- grepEcols(f, "Intensity ", split = "\t")) ## careful at the space!
(cptac <- readMSnSet2(f, ecol = e,
                      fnames = "Sequence",
                      sep = "\t"))
```

We can access the expression data with `exprs` and the feature
meta-data with `fData`.

For the sake of simplicity, we can clean up the feature variables and
only keep those of interest. It is possible to do this interactively
with

```{r selectfeats0, eval = FALSE}
cptac <- selectFeatureData(cptac)
```

or by setting the feature variables of interest.

```{r selectfeats}
cptac <- selectFeatureData(cptac,
                           fcol = c("Proteins",
                                    "Potential.contaminant",
                                    "Reverse",
                                    "Sequence"))
```

Let's also add sample annotations:

```{r pdata}
cptac$group <- rep(c("6A", "6B"), each = 3)
cptac$sample <- rep(7:9, 2)
sampleNames(cptac) <- sub("Intensity.", "", sampleNames(cptac))
pData(cptac)
```

# Quantitative data processing

## Filtering out contaminants 

```{r conts}
table(sel_conts <- fData(cptac)$Potential.contaminant != "+")
```

```{r rev}
table(sel_rev <- fData(cptac)$Reverse != "+")
```

```{r filtering}
(cptac <- cptac[sel_conts & sel_rev, ])
```

Note how the filtering has been recorded in the object's processing
log.

## Notes on missing values

Unfortunately, some software uses 0 irrespecitve whether the data has
intensity zero and when the data haven't been observer. Below we fix
this.


```{r setna}
exprs(cptac)[exprs(cptac) == 0] <- NA
table(is.na(exprs(cptac)))
```

```{r napac, fig.cap = "Overview of missing data"}
napac <- cptac
exprs(napac)[!is.na(exprs(napac))] <- 1
naplot(napac)
```

```{r nna}
fData(cptac)$nNA <- apply(exprs(cptac), 1, function(x) sum(is.na(x)))
table(fData(cptac)$nNA)
```

(Note that some peptides aren't seen at all because these 6 samples
are a subset of a larger dataset, and these features are present in
the other acquisitions.)

From here on, one could **filter** data with missing values, which however
sacrifices a lot of data.

```{r filterNA}
(cptac <- filterNA(cptac))
```

Perform **imputation**, considering the underlying nature of missingness,
i.e missing not at random (left-censored) or at random.

![Root-mean-square error (RMSE) observations standard deviation ratio (RSR), KNN and MinDet imputation. Lower (blue) is better.](./Figures/imp-sim.png)

See Lazar *et al.* [Accounting for the Multiple Natures of Missing
Values in Label-Free Quantitative Proteomics Data Sets to Compare
Imputation
Strategies](http://dx.doi.org/10.1021/acs.jproteome.5b00981).

The best solution is arguably to handle missing values at **the
statistical test level** (see later).

## Log transformation

```{r log}
(cptac <- log(cptac, base = 2))
```

## Normalisation

Normalisation is handled by the `normalise` (or `normalize`) function.

```{r norm}
(cptac <- normalise(cptac, method = "quantiles"))
```

## Summarisation

So far we have quantitation values at the peptide level, while the
level of interest are proteins. We can take all peptides that are
associated to a protein (or protein group), as defined by the
`Proteins` feature variable and aggregate them using a preferred
operation.

```{r featsfig, fig.cap = "Aggregation between different levels.", echo = FALSE}
knitr::include_graphics("https://rformassspectrometry.github.io/Features/articles/Features_files/figure-html/featuresplot-1.png")
```


```{r featsfig2, fig.cap = "Examples of aggregations.", echo = FALSE}
knitr::include_graphics("https://rformassspectrometry.github.io/Features/articles/Features_files/figure-html/plotstat-1.png")
```


```{r combine}
(cptac <- combineFeatures(cptac, fcol = "Proteins", method = "mean"))
```

**As you will see in the next section, there are much better aggregation
function than the mean!**

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
